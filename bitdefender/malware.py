#!/usr/bin/python3
from myutils import clear_endlines
from myutils import get_params
from myutils import get_file
from myutils import special_characters
from myutils import split_characters

urls = open("./data/urls/urls.in", "r").readlines()
unnallowed_extensions_r = open("data2.txt", "r").readlines()
clear_endlines(unnallowed_extensions_r)
unnallowed_extensions = set(unnallowed_extensions_r)

safe_file_extensions = ["htm", "com", "do"]
sus_parts = set(["v=ver", "#form", "/exe/", "/raw/", "mod_",
    "args=", "server/", "=download", "host", "client", "admin", "login",
    "module=", "?environment", "&environment", ".ru.com", "~",
    "export="
])

url_checks = ['has_suspicious_parts', 'waits_for_input', 'check_at', 'has_empty_var']
domain_checks = ['all_digits_domain']
params_checks = ['has_ambigous_params', 'long_params', 'param_is_a_file']
file_checks = ['check_semi_colon', 'only_digits_file', 'long_file_name', 'is_executable', 'file_contains_sp_chr']

def has_suspicious_parts(url: str):
    if any(map(url.__contains__, sus_parts)):
        return "suspicious_link"

def check_at(url: str):
    at = url.find('@')
    if at == -1:
        return
    new_url = url[at + 1:]
    if new_url.count('.') > 0 and new_url.count('/') == 0:
        return "redirect_link"    

def has_empty_var(url: str):
    if url.__contains__("=&") and not url.__contains__("==&"):
        return "empty_var"

def waits_for_input(url: str):
    if url[-1] == "=" and url[-5:-1] != "page":
        return "waits_for_input"

def all_digits_domain(full_domain: str, url: str):
    domain = full_domain.split(".")[0]
    if domain.isdigit() and len(domain) > 4:
        return "all_digits_domain"

def has_ambigous_params(params: list):
    short_params = 0
    for param in params:
        split = param.split("=")
        variable = ("NO_VAR", split[0]) [len(split) > 1]
        short_params += (0, 1) [len(variable) < 2]
    if short_params > 2:
        return "ambigous_params"

def a_lot_of_query_params(params: list):
    if len(params) > 5:
        return "too_many_params" 

def long_params(params: list):
    for param in params:
        value = param.split('=')[-1]
        if value and len(value) > 32 and not any(map(value.__contains__, split_characters)) and not value.isalpha():
            return "long_params"

def param_is_a_file(params: list):
    for param in params:
        value = param.split('=')[-1]
        if value and value.count(".") == 1 and not value[value.find('.') + 1:] in safe_file_extensions:
            return "param_is_a_file"

def check_semi_colon(file: str, has_params: bool, url: str):
    if not file or file == url:
        return

    extension = file.find(".")
    semicolon = False
    if extension != -1:
        for i in range(extension + 1, len(file) - 1):
            if file[i] == ";":
                semicolon = True
                break
            if not file[i].isalpha():
                break
    
    if semicolon:
        return "has_semicolon"

def is_executable(file: str, has_params: bool, url: str):
    if not file or file == url:
        return

    extension = file.split(".")[-1]
    if extension in ['htm']:
        return "SAFE"
    
    if extension in unnallowed_extensions:
        return "binary_file"

def only_digits_file(file: str, has_params: bool, url: str):
    if not file:
        return
    if file.split('.')[0].isdigit() and has_params:
        return "only_digits_file"

def long_file_name(file: str, has_params: bool, url: str):
    if not file:
        return
    if len(file) >= 32 and not any(map(file.__contains__, split_characters)):
        return "long_file_name"

def file_contains_sp_chr(file: str, has_params: bool, url: str):
    if not file:
        return
    if any(map(file.__contains__, special_characters)):
        return "file_contains_special_characters"

def run_checks(checks, **kwargs):
    response, score = "", 0    
    for check in checks:
        result = globals()[check](**kwargs)
        if result:
            if result == 'SAFE':
                response, score = "SAFE", -69
                return response, score
            response, score = result + " + " + response, score + 1

    return response, score
               
def is_malware(url: str):
    full_domain = url.split("/")[0]
    file, has_params, clean_url, query_string = get_file(url)
    params = get_params(query_string, clean_url)
    
    params_response, params_score = "", 0
    if params:
        params_response, params_score = run_checks(params_checks, params = params)

    url_response, url_score = run_checks(url_checks, url = url)
    domain_response, domain_score = run_checks(domain_checks, full_domain = full_domain, url = url)
    file_response, file_score = run_checks(file_checks, file = file, has_params = has_params, url = url)
    
    response = params_response + ' ' + url_response + ' ' + domain_response + ' ' + file_response
    response = response.replace(' ', '')
    score = params_score + url_score + domain_score + file_score

    if score < 0:
        response = "SAFE"
    return ((False, response), (True, str(response) + str(score))) [score >= 1]